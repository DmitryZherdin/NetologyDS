# -*- coding: utf-8 -*-
"""DZ2_DS_management.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jtRmQ-3kG6uEn39ypuESxgj7yorf9iZW

Импортируем необходимые библиотеки
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib import cm
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.neighbors import LocalOutlierFactor
from sklearn.ensemble import RandomForestClassifier, IsolationForest

"""Определяем функции для работы с данными"""

def data_type(data):
  num = data.select_dtypes([np.number]).columns.tolist()
  cat = data.select_dtypes('object').columns.tolist()
  return num, cat

def numeric_data_EDA(data):
  df_EDA = data.describe().T.drop(['count', '25%', '50%', '75%'], axis = 1)
  df_EDA['NAN_Percentage'] = 100 * data.isna().sum() / len(data)
  for col in data.columns:
    q1 = data[col].quantile(0.25)
    q3 = data[col].quantile(0.75)
    IQR = q3 - q1
    upper = q3 + 1.5 * IQR
    lower = q1 - 1.5 * IQR
    outliers_count = data.loc[(data[col] > upper)|(data[col] < lower), col].count()
    df_EDA.loc[col, 'Outliers_Percentage'] = (100 * outliers_count / len(data))
  df_EDA['skewness'] = data.skew()
  df_EDA['kurtosis'] = data.kurt()
  df_EDA.round(2)
  return df_EDA

def categorical_data_EDA(data):

  df_EDA = pd.concat([data.apply(lambda x: x.nunique()),
                      data.apply(lambda x: [x.unique()]).T,
                      data.apply(lambda x: x.mode()).T,
                      100 * data.isna().sum() / len(data)], axis = 1, sort=False)
  df_EDA.columns = ['unique', 'values', 'mode', 'NAN_Percentage']
  return df_EDA

def Fill_NA_LinReg(data, column, cols = None):
  if cols == None:
    cols = data.select_dtypes([np.number]).columns.tolist()
    cols.remove(column)
  data_tmp = data.dropna()
  data_tmp2 = data.fillna(data.mean())
  model = make_pipeline(StandardScaler(), LinearRegression())
  model.fit(data_tmp[cols], data_tmp[column])
  data.loc[data[data[column].isna()].index, column] = model.predict(data_tmp2[data[column].isna()][cols])

def outliers_LogReg(data):
  LOF = LocalOutlierFactor(novelty=True)
  LOF.fit(data)
  pred = LOF.predict(data)
  outlier_index = np.where(pred == -1)
  return data.drop(index = outlier_index[0])

def model_test(X,y):
  scaler = StandardScaler()
  X = scaler.fit_transform(X)
  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)
  model_RFC = RandomForestClassifier(random_state = 42)
  model_RFC.fit(X_train, y_train)
  return model_RFC.score(X_test, y_test)

"""Загружаем данные"""

df = pd.read_csv('winequalityN.csv')

"""Проводим исследовательский анализ данных"""

df.info()

df.head()

"""Определяем категориальные и количественные признаки"""

num, cat = data_type(df)

"""Исследуем категориальные признаки"""

categorical_data_EDA(df[cat])

sns.set_style({'axes.grid': True})
sns.countplot(x = 'type', data = df);

"""Исследуем количественные признаки"""

round(numeric_data_EDA(df[num]), 2)

sns.countplot(x = 'quality', data = df.loc[df['type'] == 'white']);

sns.countplot(x = 'quality', data = df.loc[df['type'] == 'red']);

sns.countplot(x = 'quality', data = df);

plt.figure(figsize=(15,8))
data_corr = df[num].corr()
data_corr = np.round(data_corr, 2)
#data_corr[np.abs(data_corr) < 0.05] = 0
plt.grid(False)
sns.heatmap(data_corr, annot=True, linewidths=.5, cmap='coolwarm')
plt.title('Correlation matrix');

sns.pairplot(df, hue = 'type');

"""Зависимость целевого переменной от признаков носит нелинейный характер, для прогнозирования будем использовать древесную модель RandomForestClassifier

Заполняем пропуски
"""

df.isna().sum()

df_fillna = df.copy()
col_with_NA = df.columns[df.isna().any()].tolist()
for column in col_with_NA:
  Fill_NA_LinReg(df_fillna, column)

df_fillna.isna().sum()

df_white = df_fillna.loc[df_fillna['type'] == 'white'].drop('type', axis = 1).copy().reset_index(drop = True)
df_red = df_fillna.loc[df_fillna['type'] == 'red'].drop('type', axis = 1).copy().reset_index(drop = True)

"""Исследуем данные на наличие выбросов и удаляем их"""

fig, axs = plt.subplots(4, 3, figsize=(20, 20))
col = 0
data = df_white
for i in range(4):
  for j in range(3):
    sns.boxplot(data[data.columns[col]], ax=axs[i, j], color = cm.Paired(col))
    axs[i, j].set_xlabel(data.columns[col], fontsize = 20)
    col += 1

fig, axs = plt.subplots(4, 3, figsize=(20, 20))
col = 0
data = df_red
for i in range(4):
  for j in range(3):
    sns.boxplot(data[data.columns[col]], ax=axs[i, j], color = cm.Paired(col))
    axs[i, j].set_xlabel(data.columns[col], fontsize = 20)
    col += 1

fig, axs = plt.subplots(4, 3, figsize=(20, 20))
data = df_fillna.drop('type', axis = 1)
col = 0
for i in range(4):
  for j in range(3):
    sns.histplot(data[data.columns[col]], kde = True, ax = axs[i, j], color = cm.Paired(col))
    axs[i, j].set_xlabel(data.columns[col], fontsize = 20)
    col += 1

fig, axs = plt.subplots(4, 3, figsize=(20, 20))
data = df_red
col = 0
for i in range(4):
  for j in range(3):
    sns.histplot(data[data.columns[col]], kde = True, ax = axs[i, j], color = cm.Paired(col))
    axs[i, j].set_xlabel(data.columns[col], fontsize = 20)
    col += 1

fig, axs = plt.subplots(4, 3, figsize=(20, 20))
data = df_white
col = 0
for i in range(4):
  for j in range(3):
    sns.histplot(data[data.columns[col]], kde = True, ax = axs[i, j], color = cm.Paired(col))
    axs[i, j].set_xlabel(data.columns[col], fontsize = 20)
    col += 1

"""Распределение признаков для красного и белого вин различно, целесообразно разделить датасет по типу вина."""

df_red_outliners = outliers_LogReg(df_red)
df_white_outliners = outliers_LogReg(df_white)

"""Строим модель и определяем качество обучения"""

model_test(X = df_red_outliners.drop(['quality'], axis = 1), y = df_red_outliners['quality'])

model_test(X = df_white_outliners.drop(['quality'], axis = 1), y = df_white_outliners['quality'])

model_test(X = df_red.drop(['quality'], axis = 1), y = df_red['quality'])

model_test(X = df_white.drop(['quality'], axis = 1), y = df_white['quality'])

model_test(X = df_fillna.drop(['type' ,'quality'], axis = 1), y = df_fillna['quality'])

"""Выводы:
1. Качество предсказания оценки вина неочень высокое.
2. Исключение выбросов в среднем неизменило качество моделей (для красного вина качество снизилось, для белого повысилось).
3. Разделение датасета по видам вина незначительно повысило качество модели для белого вина, но снизило для красного.
"""